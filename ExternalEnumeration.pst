<?xml version="1.0"?><st-source><!-- Name: ExternalEnumerationNotice: The MIT License (MIT)Copyright (c) 2014 Randy CoulmanPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE.Comment: # ExternalEnumerationAdds an external Enumerator that provides the full richness of theSmalltalk enumeration protocol to an internal collection or complexdata structure without exposing the entire collection.ExternalEnumeration is licensed under the MIT license.  See thecopyright tab in the RB, the `notice` property of this package, or the`LICENSE` file on GitHub.ExternalEnumeration's primary home is the [Cincom Public Store Repository](http://www.cincomsmalltalk.com/CincomSmalltalkWiki/Public+Store+Repository).Check there for the latest version.  It is also on[GitHub](https://github.com/randycoulman/ExternalEnumeration).ExternalEnumeration was developed in VW 7.9.1, but is compatible withany version of VisualworksSmalltalk. If you find any incompatibilities,let me know (see below for contact information) or file an issue onGitHub.# IntroductionSmalltalk collections have a rich protocol for enumerating theirelements: simple iteration with `do:`, mapping with `collect:`,filtering with `select:` and `reject:`, reducing with `fold:` and`inject:into:`, and more.Many systems contain objects that are logically collections, butrightfully do not inherit from classes in the collection hierarchy.Perhaps they contain a collection internally, but have a morerestricted API for interacting with the collection.Some systems contain complex data structures that need to beenumerated.  It is often possible to expose some kind of a `do:`method for enumerating the elements of the structure.`Behaviour>>subclassesDo:` and `VisualComponent>>childrenDo:` areexamples.If we want to provide the full enumeration API in these cases, ourchoices are limited:* Expose an internal collection via a method.  This allows client code  access to the full enumeration API, but also allows access to the  full collection API.  This can be dangerous, as the client code can  then modify the collection as well.  For complex data structures,  there isn't even an internal collection to expose.* Use [traits](http://scg.unibe.ch/research/traits), assuming there is  a functional implementation for your Smalltalk.* Implement the full enumeration API on the class, delegating the  methods to the internal collection.  This is a lot of tedious work  that must be repeated for each collection-like object in the system.ExternalEnumeration provides a new option to solve these problems.  Itprovides `Enumerator`, an object that takes a target object and a`do:` selector and provides the full, rich enumeration API thatSmalltalk programmers expect.# UsageTo create an `Enumerator`, send the `#on:selector:` message to the`Enumerator` class.  The resulting enumerator responds to all of thenormal collection enumeration messages.  The selector must be the nameof a method that provides `do:` semantics for the target object.```subclasses := Enumerator on: Collection selector: #allSubclassesDo:.(subclasses groupedBy: #superclass) inspect.```Some enumeration messages return a collection (`collect:`, `select:`,`reject:`, and `groupedBy:`).  By default, the resulting collectionwill be an `OrderedCollection` (or a `Dictionary` whose values are`OrderedCollections` in the case of `groupedBy:`).  If you'd like touse a different collection type (like `Set` or `Array`), you can usethe `#on:selector:species:` method instead:```MyCollectionObject>>elements    ^Enumerator on: internalElements selector: #do: species: Set````Enumerator` currently implements the following methods:* `allSatisfy:`* `anySatisfy:`* `collect:`* `detect:`* `detect:ifFound:`* `detect:ifFound:ifNone:`* `detect:ifNone:`* `do:`* `do:separatedBy:`* `fold:`* `groupedBy:`* `inject:into:`* `reject:`* `select:`# ContributingI'm happy to receive bug fixes and improvements to this package.  Ifyou'd like to contribute, please publish your changes as a "branch"(non-integer) version in the Public Store Repository and contact me asoutlined below to let me know.  I will consider merging your changesback into the "trunk" as soon as I can review them.# Contact InformationIf you have any questions about ExternalEnumeration and how to use it, feelfree to contact me.* Web site: http://randycoulman.com* Blog: Courageous Software (http://randycoulman.com/blog)* E-mail: randy _at_ randycoulman _dot_ com* Twitter: @randycoulman* GitHub: randycoulmanDbIdentifier: /Users/randy/repositories/store/RCSmalltalkDbTrace: 1674DbUsername: randyDbVersion: 1DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' ''))PackageName: ExternalEnumerationParcel: #('ExternalEnumeration')PrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle))PrerequisiteParcels: #(#('Base VisualWorks' ''))PrintStringCache: (1,randy)Version: 1Date: 8:04:13 AM April 23, 2014 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 7.9.1 of October 18, 2012 on April 23, 2014 at 8:04:13 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>ExternalEnumeration</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>ExternalEnumeration</package></attributes></name-space><class><name>Enumerator</name><environment>ExternalEnumeration</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target selector species </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ExternalEnumeration</package></attributes></class><methods><class-id>ExternalEnumeration.Enumerator</class-id> <category>initialize-release</category><body package="ExternalEnumeration">initializeTarget: anObject selector: aSelector species: aClass	target := anObject.	selector := aSelector.	species := aClass</body></methods><methods><class-id>ExternalEnumeration.Enumerator</class-id> <category>enumerating</category><body package="ExternalEnumeration">collect: aBlock	| stream |	stream := species new writeStream.	self do: [:each | stream nextPut: (aBlock value: each)].	^stream contents</body><body package="ExternalEnumeration">detect: aBlock	^self detect: aBlock ifNone: [self notFoundError]</body><body package="ExternalEnumeration">detect: aBlock ifFound: foundBlock	^self		detect: aBlock		ifFound: foundBlock		ifNone: [nil]</body><body package="ExternalEnumeration">detect: aBlock ifFound: foundBlock ifNone: notFoundBlock	| found |	found := self detect: aBlock ifNone: [^notFoundBlock value].	^foundBlock cull: found</body><body package="ExternalEnumeration">detect: aBlock ifNone: notFoundBlock	self do: [:each | (aBlock value: each) ifTrue: [^each]].	^notFoundBlock value</body><body package="ExternalEnumeration">do: aBlock 	^target perform: selector with: aBlock</body><body package="ExternalEnumeration">do: aBlock separatedBy: separatorBlock	| first |	first := true.	self do: 			[:each |			first ifTrue: [first := false] ifFalse: [separatorBlock value].			aBlock value: each]</body><body package="ExternalEnumeration">fold: aBlock	| firstValue nextValue |	firstValue := Object new.	nextValue := firstValue.	self do: 			[:each |			nextValue := firstValue == nextValue						ifTrue: [each]						ifFalse: [aBlock value: nextValue value: each]].	^nextValue == firstValue		ifTrue: [self emptyCollectionError]		ifFalse: [nextValue]</body><body package="ExternalEnumeration">groupedBy: aBlock	| result |	result := Dictionary new.	self do: 			[:each |			| key collection |			key := aBlock value: each.			collection := result at: key ifAbsentPut: [OrderedCollection new].			collection add: each].	species == OrderedCollection		ifFalse: 			[result				keysAndValuesDo: [:key :value | result at: key put: (species withAll: value)]].	^result</body><body package="ExternalEnumeration">inject: anObject into: aBlock 	| result |	result := anObject.	self do: [:each | result := aBlock value: result value: each].	^result</body><body package="ExternalEnumeration">reject: aBlock 	^self select: [:each | (aBlock value: each) not]</body><body package="ExternalEnumeration">select: aBlock	| stream |	stream := species new writeStream.	self do: [:each | (aBlock value: each) ifTrue: [stream nextPut: each]].	^stream contents</body></methods><methods><class-id>ExternalEnumeration.Enumerator</class-id> <category>private - errors</category><body package="ExternalEnumeration">emptyCollectionError	self error: #errEmptyCollection &lt;&lt; #dialogs &gt;&gt; 'this collection is empty'</body><body package="ExternalEnumeration">notFoundError	^self class notFoundSignal raise</body></methods><methods><class-id>ExternalEnumeration.Enumerator</class-id> <category>testing</category><body package="ExternalEnumeration">allSatisfy: aBlock	self do: [:each | (aBlock value: each) ifFalse: [^false]].	^true</body><body package="ExternalEnumeration">anySatisfy: aBlock	self do: [:each | (aBlock value: each) ifTrue: [^true]].	^false</body></methods><methods><class-id>ExternalEnumeration.Enumerator class</class-id> <category>instance creation</category><body package="ExternalEnumeration">on: anObject selector: aSelector	^self on: anObject selector: aSelector species: OrderedCollection</body><body package="ExternalEnumeration">on: anObject selector: aSelector species: aClass	^self new initializeTarget: anObject selector: aSelector species: aClass</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>